// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.txt in the project root for license information.

using System;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.Globalization;
using System.Text;
using System.Text.RegularExpressions;

namespace Microsoft.AspNet.Routing.Template
{
    public class TemplateBinder
    {
        public TemplateBinder(Template template)
        {
            if (template == null)
            {
                throw new ArgumentNullException("template");
            }

            Template = template;
        }

        public Template Template { get; private set; }

        public BoundRouteTemplate Bind(IDictionary<string, object> defaults, IDictionary<string, object> ambientValues, IDictionary<string, object> values)
        {
            var context = GetAcceptedValues(defaults, ambientValues, values);
            if (context == null)
            {
                // We couldn't get values for all the required parameters
                return null;
            }


        }

        public TemplateBindingContext GetAcceptedValues(IDictionary<string, object> defaults, IDictionary<string, object> ambientValues, IDictionary<string, object> values)
        {
            var context = new TemplateBindingContext(defaults, values);

            // Step 1: Get the list of values we're going to try to use to match and generate this URI

            // Find out which entries in the URI are valid for the URI we want to generate.
            // If the URI had ordered parameters a="1", b="2", c="3" and the new values
            // specified that b="9", then we need to invalidate everything after it. The new
            // values should then be a="1", b="9", c=<no value>.
            for (var i = 0; i < Template.Parameters.Count; i++)
            {
                var parameter = Template.Parameters[i];

                // If it's a parameter subsegment, examine the current value to see if it matches the new value
                var parameterName = parameter.Name;

                object newParameterValue;
                var hasNewParameterValue = values.TryGetValue(parameterName, out newParameterValue);
                if (hasNewParameterValue)
                {
                    context.Use(parameterName);
                }

                object currentParameterValue;
                var hasCurrentParameterValue = ambientValues.TryGetValue(parameterName, out currentParameterValue);

                if (hasNewParameterValue && hasCurrentParameterValue)
                {
                    if (!RoutePartsEqual(currentParameterValue, newParameterValue))
                    {
                        // Stop copying current values when we find one that doesn't match
                        break;
                    }
                }

                // If the parameter is a match, add it to the list of values we will use for URI generation
                if (hasNewParameterValue)
                {
                    if (IsRoutePartNonEmpty(newParameterValue))
                    {
                        context.Accept(parameterName, newParameterValue);
                    }
                }
                else
                {
                    if (hasCurrentParameterValue)
                    {
                        context.Accept(parameterName, currentParameterValue);
                    }
                }
            };

            // Add all remaining new values to the list of values we will use for URI generation
            foreach (var kvp in values)
            {
                if (IsRoutePartNonEmpty(kvp.Value))
                {
                    context.Accept(kvp.Key, kvp.Value);
                }
            }

            // Add all current values that aren't in the URI at all
            foreach (var kvp in ambientValues)
            {
                var parameter = GetParameter(kvp.Key);
                if (parameter == null)
                {
                    context.Accept(kvp.Key, kvp.Value);
                }
            }

            // Accept all remaining default values if they match a required parameter
            for (int i = 0; i < Template.Parameters.Count; i++)
            {
                var parameter = Template.Parameters[i];
                if (parameter.IsOptional || parameter.IsCatchAll)
                {
                    continue;
                }

                if (context.NeedsValue(parameter.Name))
                {
                    // Add the default value only if there isn't already a new value for it and
                    // only if it actually has a default value, which we determine based on whether
                    // the parameter value is required.
                    context.AcceptDefault(parameter.Name);
                }
            }

            for (var i = 0; i < Template.Parameters.Count; i++)
            {
                var parameter = Template.Parameters[i];
                if (parameter.IsOptional || parameter.IsCatchAll)
                {
                    continue;
                }

                if (!context.AcceptedValues.ContainsKey(parameter.Name))
                {
                    // We don't have a value for this parameter, so we can't generate a url.
                    return null;
                }
            }

            if (context.UnusedDefaults != null)
            {
                foreach (var filter in context.UnusedDefaults)
                {
                    object value;
                    if (values.TryGetValue(filter.Key, out value))
                    {
                        if (RoutePartsEqual(value, filter.Value))
                        {
                            context.Use(filter.Key);
                        }
                        else
                        {
                            // If there is a non-parameterized value in the route and there is a
                            // new value for it and it doesn't match, this route won't match.
                            return null;
                        }
                    }
                }
            }

            return context;
        }

        public BoundRouteTemplate BindValues(TemplateBindingContext context)
        {
            // Step 2: If the route is a match generate the appropriate URI

            StringBuilder uri = new StringBuilder();
            StringBuilder pendingParts = new StringBuilder();

            bool pendingPartsAreAllSafe = false;
            bool blockAllUriAppends = false;

            for (int i = 0; i < Template.Segments.Count; i++)
            {
                var segment = Template.Segments[i];

                // Segments are treated as all-or-none. We should never output a partial segment.
                // If we add any subsegment of this segment to the generated URI, we have to add
                // the complete match. For example, if the subsegment is "{p1}-{p2}.xml" and we
                // used a value for {p1}, we have to output the entire segment up to the next "/".
                // Otherwise we could end up with the partial segment "v1" instead of the entire
                // segment "v1-v2.xml".
                bool addedAnySubsegments = false;

                for (var j = 0; j < segment.Parts.Count; j++)
                {
                    var part = segment.Parts[j];

                    if (part.IsLiteral)
                    {
                        // If it's a literal we hold on to it until we are sure we need to add it
                        pendingPartsAreAllSafe = true;
                        pendingParts.Append(part.Text);
                    }
                    else if (part.IsParameter)
                    {
                        if (pendingPartsAreAllSafe)
                        {
                            // Accept
                            if (pendingParts.Length > 0)
                            {
                                if (blockAllUriAppends)
                                {
                                    return null;
                                }

                                // Append any pending literals to the URI
                                uri.Append(pendingParts.ToString());
                                pendingParts.Length = 0;

                                addedAnySubsegments = true;
                            }
                        }
                        pendingPartsAreAllSafe = false;

                        // If it's a parameter, get its value
                        object acceptedValue;
                        bool hasAcceptedParameterValue = context.AcceptedValues.TryGetValue(part.Name, out acceptedValue);
                        if (hasAcceptedParameterValue)
                        {
                            context.Use(part.Name);
                        }

                        object defaultParameterValue = null;
                        if (defaults != null)
                        {
                            defaults.TryGetValue(part.Name, out defaultParameterValue);
                        }

                        if (RoutePartsEqual(acceptedValue, defaultParameterValue))
                        {
                            // If the accepted value is the same as the default value, mark it as pending since
                            // we won't necessarily add it to the URI we generate.
                            pendingParts.Append(Convert.ToString(acceptedValue, CultureInfo.InvariantCulture));
                        }
                        else
                        {
                            if (blockAllUriAppends)
                            {
                                return null;
                            }

                            // Add the new part to the URI as well as any pending parts
                            if (pendingParts.Length > 0)
                            {
                                // Append any pending literals to the URI
                                uri.Append(pendingParts.ToString());
                                pendingParts.Length = 0;
                            }
                            uri.Append(Convert.ToString(acceptedValue, CultureInfo.InvariantCulture));

                            addedAnySubsegments = true;
                        }

                    }
                }


                if (addedAnySubsegments)
                {
                    // See comment above about why we add the pending parts
                    if (pendingParts.Length > 0)
                    {
                        if (blockAllUriAppends)
                        {
                            return null;
                        }

                        // Append any pending literals to the URI
                        uri.Append(pendingParts.ToString());
                        pendingParts.Length = 0;
                    }
                }

                if (pendingPartsAreAllSafe)
                {
                    // Accept
                    if (pendingParts.Length > 0)
                    {
                        if (blockAllUriAppends)
                        {
                            return null;
                        }

                        // Append any pending literals to the URI
                        uri.Append(pendingParts);
                        pendingParts.Clear();
                    }
                }

                pendingPartsAreAllSafe = false;

                // Guard against appending multiple separators for empty segments
                if (pendingParts.Length > 0 && pendingParts[pendingParts.Length - 1] == '/')
                {
                    // Dev10 676725: Route should not be matched if that causes mismatched tokens
                    // Dev11 86819: We will allow empty matches if all subsequent segments are null
                    if (blockAllUriAppends)
                    {
                        return null;
                    }

                    // Append any pending literals to the URI (without the trailing slash) and prevent any future appends
                    uri.Append(pendingParts.ToString(0, pendingParts.Length - 1));
                    pendingParts.Length = 0;
                    blockAllUriAppends = true;
                }
                else
                {
                    pendingParts.Append("/");
                }
            }

            // Encode the URI before we append the query string, otherwise we would double encode the query string
            var encoded = new StringBuilder();
            encoded.Append(UriEncode(uri.ToString()));
            uri = encoded;


            // Generate the query string
            bool firstParam = true;
            foreach (var kvp in context.UnusedValues)
            {
                uri.Append(firstParam ? '?' : '&');
                firstParam = false;

                uri.Append(Uri.EscapeDataString(kvp.Key));
                uri.Append('=');
                uri.Append(Uri.EscapeDataString(Convert.ToString(kvp.Value, CultureInfo.InvariantCulture)));
            }

            return new BoundRouteTemplate()
            {
                Path = uri.ToString(),
            };
        }

        private static string UriEncode(string str)
        {
            string escape = Uri.EscapeUriString(str);
            return Regex.Replace(escape, "([#?])", EscapeReservedCharacters);
        }

        private static string EscapeReservedCharacters(Match m)
        {
            return "%" + Convert.ToUInt16(m.Value[0]).ToString("x2", CultureInfo.InvariantCulture);
        }

        private TemplatePart GetParameter(string name)
        {
            for (int i = 0; i < Template.Parameters.Count; i++)
            {
                var parameter = Template.Parameters[i];
                if (string.Equals(parameter.Name, name, StringComparison.OrdinalIgnoreCase))
                {
                    return parameter;
                }
            }

            return null;
        }

        private static bool RoutePartsEqual(object a, object b)
        {
            string sa = a as string;
            string sb = b as string;

            if (sa != null && sb != null)
            {
                // For strings do a case-insensitive comparison
                return string.Equals(sa, sb, StringComparison.OrdinalIgnoreCase);
            }
            else
            {
                if (a != null && b != null)
                {
                    // Explicitly call .Equals() in case it is overridden in the type
                    return a.Equals(b);
                }
                else
                {
                    // At least one of them is null. Return true if they both are
                    return a == b;
                }
            }
        }

        private static bool IsRoutePartNonEmpty(object routePart)
        {
            var routePartString = routePart as string;
            if (routePartString == null)
            {
                return routePart != null;
            }
            else
            {
                return routePartString.Length > 0;
            }
        }

        private class TemplateBindingContext
        {
            private readonly IDictionary<string, object> _defaults;

            private readonly Dictionary<string, object> _acceptedValues;
            private readonly Dictionary<string, object> _unusedValues;
            private readonly Dictionary<string, object> _unusedDefaults;

            public TemplateBindingContext(
                IDictionary<string, object> defaults,
                IDictionary<string, object> values)
            {
                if (values == null)
                {
                    throw new ArgumentNullException("values");
                }

                _defaults = defaults;

                _acceptedValues = new Dictionary<string, object>(StringComparer.OrdinalIgnoreCase);
                _unusedValues = new Dictionary<string, object>(values, StringComparer.OrdinalIgnoreCase);

                if (_defaults != null)
                {
                    _unusedDefaults = new Dictionary<string, object>(defaults, StringComparer.OrdinalIgnoreCase);
                }
            }

            public Dictionary<string, object> AcceptedValues
            {
                get { return _acceptedValues; }
            }

            public Dictionary<string, object> UnusedValues
            {
                get { return _unusedValues; }
            }

            public Dictionary<string, object> UnusedDefaults
            {
                get { return _unusedDefaults; }
            }

            public void Accept(string key, object value)
            {
                if (!_acceptedValues.ContainsKey(key))
                {
                    _acceptedValues.Add(key, value);
                }
            }

            public void AcceptDefault(string key)
            {
                Contract.Assert(!_acceptedValues.ContainsKey(key));

                object value;
                if (_defaults != null && _defaults.TryGetValue(key, out value))
                {
                    _unusedDefaults.Remove(key);
                    _acceptedValues.Add(key, value);
                }
            }

            public bool NeedsValue(string key)
            {
                return !_acceptedValues.ContainsKey(key);
            }

            public void Use(string key)
            {
                _unusedValues.Remove(key);
            }
        }

    }
}
